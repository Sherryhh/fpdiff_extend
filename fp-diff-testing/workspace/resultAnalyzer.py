import os
import struct
import numpy as np
import csv
import itertools
import subprocess
from header import *

# set working directory
WD = os.path.dirname(os.path.abspath(__file__))
os.chdir(WD)

outputsDir = WD + "/outputs/"

# declare names of int input file
intPath = bytes("./inputs/easyClassificationInputs/intInput2s", encoding='utf8')

TOLERANCE = 0.00000001
CATEGORYTALLY = [0,0,0,0,0]
UNIQUE_DISCREPANCIES = {}

# for ignoring the incorrect classes generated by the now-frozen classifier state
CLASS_IGNORE = []

def condenseLog(csvFileName):
    global UNIQUE_DISCREPANCIES
    with open("logs/condensed_{}".format(csvFileName), 'w') as newcsv, open("logs/{}".format(csvFileName), 'r') as oldcsv:

        fieldnames = ['classNo', 'testInputSource', 'doubleInputPath', 'numberOfDoubles', 'intInputPath', 'numberOfInts', 'libraryName', 'driverName', 'funcName', 'resultFilePath', 'discrepancyType']
        writer = csv.DictWriter(newcsv, fieldnames=fieldnames)

        writer.writeheader()

        reader = csv.DictReader(oldcsv)

        currentClassNo = ''
        currentTestInput = ''
        exceptionCount = 0
        outputs = []
        keepers = {}
        previousRow = None

        # for each row in the csv file
        for row in reader:

            # if we've moved to a different source of input than previously... 
            if row["testInputSource"] != currentTestInput:

                # and if we weren't on the very first for loop execution where the above conditional is guaranteed
                if currentTestInput != '':

                    # if the outputs are consistent...
                    if isConsistent(outputs, exceptionCount):

                        # remember that those rows are non-keepers
                        keepers[currentClassNo + currentTestInput] = False

                    # otherwise, there is a discrepancy...
                    else:
                        # categorize the discrepancy and the input type that generated it
                        discrepancyType = categorizeDiscrepancy(currentTestInput, outputs, exceptionCount)
                        inputType = categorizeInput(previousRow['doubleInputPath'], previousRow['numberOfDoubles'], previousRow['intInputPath'], previousRow['numberOfInts'])

                        # if the current ClassNo doesn't have any discrepancies logged yet...
                        if currentClassNo not in UNIQUE_DISCREPANCIES.keys():
                            
                            # this is a new discrepancy so we store it
                            UNIQUE_DISCREPANCIES[currentClassNo] = [(inputType, discrepancyType)]

                            # and remember those rows as keepers
                            keepers[currentClassNo + currentTestInput] = discrepancyType

                        # otherwise, if the current classNo hasn't seen this particular kind of discrepancy yet...    
                        elif (inputType, discrepancyType) not in UNIQUE_DISCREPANCIES[currentClassNo]:

                            # save the discrepancy type
                            UNIQUE_DISCREPANCIES[currentClassNo].append((inputType, discrepancyType))

                            # and remember those rows as keepers
                            keepers[currentClassNo + currentTestInput] = discrepancyType

                        # otherwise, the current classNo has seen this discrepancy so we remember those rows as non-keepers
                        else:
                            keepers[currentClassNo + currentTestInput] = False

                # update info, reset outputs and exception count
                currentClassNo = row['classNo']
                currentTestInput = row["testInputSource"]
                outputs = []
                exceptionCount = 0

            if "EXCEPTION" in row['resultFilePath']:
                with open(row['resultFilePath'], 'r') as f:
                    outputs.append(f.read())
                exceptionCount += 1
            else:
                with open(row['resultFilePath'], 'rb') as f:
                    outputs.append(struct.unpack('d', f.read(8))[0])
            
            previousRow = row

        if isConsistent(outputs, exceptionCount):
            keepers[currentClassNo + currentTestInput] = False
        else:
            # categorize the discrepancy
            discrepancyType = categorizeDiscrepancy(currentTestInput, outputs, exceptionCount)
            inputType = categorizeInput(previousRow['doubleInputPath'], previousRow['numberOfDoubles'], previousRow['intInputPath'], previousRow['numberOfInts'])

            if currentClassNo not in UNIQUE_DISCREPANCIES.keys():
                UNIQUE_DISCREPANCIES[currentClassNo] = [(inputType, discrepancyType)]
                keepers[currentClassNo + currentTestInput] = discrepancyType
            elif (inputType, discrepancyType) not in UNIQUE_DISCREPANCIES[currentClassNo]:
                UNIQUE_DISCREPANCIES[currentClassNo].append((inputType, discrepancyType))
                keepers[currentClassNo + currentTestInput] = discrepancyType
            else:
                keepers[currentClassNo + currentTestInput] = False

        oldcsv.seek(0)
        next(reader)
        for row in reader:
            if keepers[row['classNo'] + row['testInputSource']]:
                writer.writerow({'classNo': row['classNo'],
                                'testInputSource': row['testInputSource'],
                                'doubleInputPath': row['doubleInputPath'],
                                'numberOfDoubles': row['numberOfDoubles'],
                                'intInputPath': row['intInputPath'],
                                'numberOfInts': row['numberOfInts'],
                                'libraryName': row['libraryName'],
                                'driverName': row['driverName'],
                                'funcName': row['funcName'],
                                'resultFilePath': row['resultFilePath'],
                                'discrepancyType': keepers[row['classNo'] + row['testInputSource']]})
    UNIQUE_DISCREPANCIES = {}

# can modify this; we've already calculated the discrepancy type in the condensing portion; just retrieve it from the csv
def analyzeLog(csvFileName):
    global CATEGORYTALLY

    with open("logs/condensed_{}".format(csvFileName), 'r') as f:

        reader = csv.DictReader(f)

        currentClassNo = ''
        currentTestInput = ''
        exceptionCount = 0
        outputs = []

        for row in reader:
            if int(row["classNo"]) in CLASS_IGNORE:
                continue
            if row["testInputSource"] != currentTestInput:
                if currentTestInput != '':
                    category = categorizeDiscrepancy(currentTestInput, outputs, exceptionCount)
                    CATEGORYTALLY[category-1] += 1
                currentClassNo = row['classNo']
                currentTestInput = row["testInputSource"]
                outputs = []
                exceptionCount = 0

            if "EXCEPTION" in row['resultFilePath']:
                with open(row['resultFilePath'], 'r') as f:
                    outputs.append(f.read())
                exceptionCount += 1
            else:
                with open(row['resultFilePath'], 'rb') as f:
                    outputs.append(struct.unpack('d', f.read(8))[0])

        category = categorizeDiscrepancy(currentTestInput, outputs, exceptionCount)
        CATEGORYTALLY[category-1] += 1

    with open("__statistics.txt", 'a') as f:
        f.write("\n\nAnalysis results from {}: {}\n".format(csvFileName, CATEGORYTALLY))
        f.write("\tTOTAL: {}".format(sum(CATEGORYTALLY)))

    print("Analysis results from {}: {}".format(csvFileName, CATEGORYTALLY))
    print("\tTOTAL: {}".format(sum(CATEGORYTALLY)))
    CATEGORYTALLY = [0,0,0,0,0]


def outputFinalCSV():
    with open("logs/condensed_CombinedTestingResults.csv") as f, open("logs/all_discrepancies.csv", 'w') as outcsv:
        fieldnames = ['classNo', 'discrepancyType', 'inputSource', 'inputs', 'libraryName', 'functionName', 'output']
        writer = csv.DictWriter(outcsv, fieldnames=fieldnames)
        writer.writeheader()
        reader = csv.DictReader(f)
        for row in reader:
            if int(row['classNo']) in CLASS_IGNORE:
                continue
            else:
                inputs = []
                with open(row['intInputPath'], 'rb') as fp:
                    for i in range(int(row['numberOfInts'])):
                        inputs.append(struct.unpack('i', fp.read(4))[0])

                with open(row['doubleInputPath'], 'rb') as fp:
                    for i in range(int(row['numberOfDoubles'])):
                        inputs.append(struct.unpack('d', fp.read(8))[0])

                if "EXCEPTION" in row['resultFilePath']:
                    with open(row['resultFilePath'], 'r') as fp:
                        result = fp.read()

                else:
                    with open(row['resultFilePath'], 'rb') as fp:
                        result = struct.unpack('d', fp.read(8))[0]

                writer.writerow({'classNo': row['classNo'],
                                'discrepancyType': row['discrepancyType'],
                                'inputSource': row['testInputSource'],
                                'inputs': inputs,
                                'libraryName': row['libraryName'],
                                'functionName': row['funcName'],
                                'output': result})

if __name__ == "__main__":

    subprocess.call(["make", "condensedLogClean"])
    subprocess.call(["rm", "-f", "logs/CombinedTestingResults.csv"])

    logs = [f for f in os.listdir("logs") if (".csv" in f and "condensed" not in f)]

    for logName in logs:
        condenseLog(logName)
        analyzeLog(logName)

    combinedLog=[]

    for logName in logs:
        with open("logs/{}".format(logName)) as f:
            reader = csv.DictReader(f)
            for row in reader:
                    combinedLog.append(row)

    with open("logs/CombinedTestingResults.csv", 'w') as f:
        fieldnames = ['classNo', 'testInputSource', 'doubleInputPath', 'numberOfDoubles', 'intInputPath', 'numberOfInts', 'libraryName', 'driverName', 'funcName', 'resultFilePath']
        writer = csv.DictWriter(f, fieldnames=fieldnames)
        writer.writeheader()
        for row in combinedLog:
            writer.writerow({'classNo': row['classNo'],
                    'testInputSource': row['testInputSource'],
                    'doubleInputPath': row['doubleInputPath'],
                    'numberOfDoubles': row['numberOfDoubles'],
                    'intInputPath': row['intInputPath'],
                    'numberOfInts': row['numberOfInts'],
                    'libraryName': row['libraryName'],
                    'driverName': row['driverName'],
                    'funcName': row['funcName'],
                    'resultFilePath': row['resultFilePath']})

    sort_csv("CombinedTestingResults.csv")
    condenseLog("CombinedTestingResults.csv")
    #prettyPrintClasses("condensed_CombinedTestingResults.csv")
    analyzeLog("CombinedTestingResults.csv")

    outputFinalCSV()
